"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMarkdownToVueRenderFn = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const gray_matter_1 = __importDefault(require("gray-matter"));
const lru_cache_1 = __importDefault(require("lru-cache"));
const markdown_1 = require("./markdown/markdown");
const parseHeader_1 = require("./utils/parseHeader");
const slash_1 = require("./utils/slash");
const chalk_1 = __importDefault(require("chalk"));
const debug = require('debug')('vitepress:md');
const cache = new lru_cache_1.default({ max: 1024 });
function createMarkdownToVueRenderFn(srcDir, options = {}, pages, userDefines, isBuild = false) {
    const md = markdown_1.createMarkdownRenderer(srcDir, options);
    pages = pages.map((p) => slash_1.slash(p.replace(/\.md$/, '')));
    return (src, file, publicDir) => {
        const relativePath = slash_1.slash(path_1.default.relative(srcDir, file));
        const cached = cache.get(src);
        if (cached) {
            debug(`[cache hit] ${relativePath}`);
            return cached;
        }
        const start = Date.now();
        const { content, data: frontmatter } = gray_matter_1.default(src);
        let { html, data } = md.render(content);
        if (isBuild) {
            // avoid env variables being replaced by vite
            html = html
                .replace(/\bimport\.meta/g, 'import.<wbr/>meta')
                .replace(/\bprocess\.env/g, 'process.<wbr/>env');
            // also avoid replacing vite user defines
            if (userDefines) {
                const regex = new RegExp(`\\b(${Object.keys(userDefines)
                    .map((key) => key.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&'))
                    .join('|')})`, 'g');
                html = html.replace(regex, (_) => `${_[0]}<wbr/>${_.slice(1)}`);
            }
        }
        // validate data.links
        const deadLinks = [];
        if (data.links) {
            const dir = path_1.default.dirname(file);
            for (let url of data.links) {
                url = url.replace(/[?#].*$/, '').replace(/\.(html|md)$/, '');
                if (url.endsWith('/'))
                    url += `index`;
                const resolved = slash_1.slash(url.startsWith('/')
                    ? url.slice(1)
                    : path_1.default.relative(srcDir, path_1.default.resolve(dir, url)));
                if (!pages.includes(resolved) &&
                    !fs_1.default.existsSync(path_1.default.resolve(dir, publicDir, `${resolved}.html`))) {
                    console.warn(chalk_1.default.yellow(`\n(!) Found dead link ${chalk_1.default.cyan(url)} in file ${chalk_1.default.white.dim(file)}`));
                    deadLinks.push(url);
                }
            }
        }
        const pageData = {
            title: inferTitle(frontmatter, content),
            description: inferDescription(frontmatter),
            frontmatter,
            headers: data.headers,
            relativePath,
            // TODO use git timestamp?
            lastUpdated: Math.round(fs_1.default.statSync(file).mtimeMs)
        };
        const vueSrc = genPageDataCode(data.hoistedTags || [], pageData).join('\n') +
            `\n<template><div>${html}</div></template>`;
        debug(`[render] ${file} in ${Date.now() - start}ms.`);
        const result = {
            vueSrc,
            pageData,
            deadLinks
        };
        cache.set(src, result);
        return result;
    };
}
exports.createMarkdownToVueRenderFn = createMarkdownToVueRenderFn;
const scriptRE = /<\/script>/;
const scriptSetupRE = /<\s*script[^>]*\bsetup\b[^>]*/;
const defaultExportRE = /((?:^|\n|;)\s*)export(\s*)default/;
const namedDefaultExportRE = /((?:^|\n|;)\s*)export(.+)as(\s*)default/;
function genPageDataCode(tags, data) {
    const code = `\nexport const __pageData = ${JSON.stringify(JSON.stringify(data))}`;
    const existingScriptIndex = tags.findIndex((tag) => {
        return scriptRE.test(tag) && !scriptSetupRE.test(tag);
    });
    if (existingScriptIndex > -1) {
        const tagSrc = tags[existingScriptIndex];
        // user has <script> tag inside markdown
        // if it doesn't have export default it will error out on build
        const hasDefaultExport = defaultExportRE.test(tagSrc) || namedDefaultExportRE.test(tagSrc);
        tags[existingScriptIndex] = tagSrc.replace(scriptRE, code + (hasDefaultExport ? `` : `\nexport default{}\n`) + `</script>`);
    }
    else {
        tags.unshift(`<script>${code}\nexport default {}</script>`);
    }
    return tags;
}
const inferTitle = (frontmatter, content) => {
    if (frontmatter.home) {
        return 'Home';
    }
    if (frontmatter.title) {
        return parseHeader_1.deeplyParseHeader(frontmatter.title);
    }
    const match = content.match(/^\s*#+\s+(.*)/m);
    if (match) {
        return parseHeader_1.deeplyParseHeader(match[1].trim());
    }
    return '';
};
const inferDescription = (frontmatter) => {
    const { description, head } = frontmatter;
    if (description !== undefined) {
        return description;
    }
    return (head && getHeadMetaContent(head, 'description')) || '';
};
const getHeadMetaContent = (head, name) => {
    if (!head || !head.length) {
        return undefined;
    }
    const meta = head.find(([tag, attrs = {}]) => {
        return tag === 'meta' && attrs.name === name && attrs.content;
    });
    return meta && meta[1].content;
};
//# sourceMappingURL=markdownToVue.js.map